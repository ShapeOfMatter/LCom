module Communicate
    ( 
    ) where

import Data.Type.Nat (Nat)
import Data.Type.Set (AsSet, IsSet, Set, Subset, subset, Union)
import qualified Data.Type.Set as Set
import Polysemy (Member, Sem, makeSem, reinterpret)
import Polysemy.Input (Input, input)
import qualified Polysemy.Internal as PI  -- God help us.
import Polysemy.Output (Output, output)

{-
--instance {-# OVERLAPS #-} (Subset s t, Subset t v) => Subset s v where
--   subset xs = subset (subset xs :: Set t)

-------- Parties --------

newtype Party = Party Nat deriving (Enum, Eq, Ord, Show)

data Located (ps :: [Party]) v = Located v
instance Functor (Located ps) where
  fmap f (Located v) = Located (f v)
instance Applicative (Located ps) where
  pure = Located
  (Located f) <*> (Located v) = Located (f v)
instance Monad (Located ps) where
  (Located v) >>= f = f v

    
-------- Effect Signatures --------

data Communicate (ps :: [Party]) s m a where  -- s is for subject, as in the subject of the verb "communicate".
  --Sender :: forall ps s m.
  --          () -> (forall recipients senders.
  --                 (Subset (AsSet recipients) ps,
  --                  Subset (AsSet senders) ps) =>
  --                 Located senders (Maybe s) -> Communicate ps s m (Located (Union recipients senders) (Maybe s)))
  SendMaybe :: forall recipients senders ps s m.
               (Subset (AsSet recipients) ps,
                Subset (AsSet senders) ps) =>
               Located senders (Maybe s) -> Communicate ps s m (Located recipients (Maybe s))

--stuff :: forall ty r. Member Eff r => Int -> Sem r (F ty)
--stuff x = send $ Stuff x
--stuff :: forall ty r. Member Eff r => Int -> Sem r (F ty)
--stuff x = send $ Stuff @ty x

--sender :: forall r ps s.
--          (Member (Communicate ps s) r) =>
--          () -> (forall recipients senders.
--                 Located senders (Maybe s) -> Sem r (Located (Union recipients senders) (Maybe s)))
--sender () = PI.send $ Sender ()
sendMaybe :: forall recipients senders ps s r m.
             (Member (Communicate ps s) r) =>
             Located senders (Maybe s) -> Sem r (Located recipients (Maybe s))
sendMaybe x = PI.send $ SendMaybe @recipients x

--makeSem ''Communicate  -- Uses template haskell to generate:
--sendMaybe :: Member (Communicate ps s) r => (Located senders s) -> Sem r (Located ... s)


-------- Effectful Helpers --------
-- In practice these will be used instead of the raw constructor.

-- Technically a handler, but it feels like it belongs here.
--clique :: forall ps cs s r a (recipients :: [Party]) (senders :: [Party]).
clique :: forall ps cs s r a.
          (IsSet ps,
           IsSet cs,
           --IsSet recipients,
           --Subset recipients cs,
           --Subset recipients ps,
           Subset cs ps) =>
          Sem (Communicate cs s ': r) a -> Sem (Communicate ps s ': r) a
clique = reinterpret _clique
  where _clique :: forall rInitial x.
                   Communicate cs s (Sem rInitial) x -> Sem (Communicate ps s ': r) x
        _clique (SendMaybe l) = sendMaybe l
class Sendable s t where
  send :: (IsSet recipients,
           Subset recipients ps,
           IsSet senders,
           Subset senders ps) =>
          Located senders t -> Communicate ps s m (Located (Union recipients senders) t)

instance Sendable s s where
  send l = fromJust <$> (sendMaybe $ Just <$> l)
instance Sendable s () where
  send = return
instance Sendable s t => Sendable s (Maybe t) where  -- Introduces some indirection, but flatens the API.
  send Nothing = return Nothing
  send (Just t) = Just <$> (send t)
instance Sendable s t => Sendable s [t] where
  send [] = return []
  send (t:ts) = liftA2 (:) (send t) (send ts)
instance (Sendable s t1, Sendable s t2) => Sendable s (t1, t2) where
  send (t1, t2) = liftA2 (,) (send t1) (send t2)


-------- Handlers --------

-- Not very useful, but easy to write, and I wanna validate any of this works today.
noEffectSingleThread :: (IsSet ps) =>
                        Sem (Communicate ps s ': r) a -> Sem r a
noEffectSingleThread = interpret (\case
  SendMaybe (Located v) -> return (Located v)
  )

-- Communication by the local party would turn into IO read/write on a network port;
-- all other communication should simply be skipped.
runMyPart :: (IsSet ps,
              Set.Member p ps) =>  -- Somehow the specific party p within ps gets passed in at the type level?
             Sem (Communicate ps s ': r) a -> Sem (Input s ': Output s ': r) a
runMyPart = undefined  -- I think I can make this work using a closed type family or something; IDK.

-- And there should be another handler, similar to noEffectSingleThread,
-- which will run single-threaded by collect a structured log of all communication. 


-}

