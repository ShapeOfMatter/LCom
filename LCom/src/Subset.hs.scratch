{-# LANGUAGE IncoherentInstances #-}
module Subset (
  known,
  Subset,
  transitive
) where

import qualified Data.Type.Set as Set
import Data.Constraint (Class, cls, Dict(..), (:-)(..), (:=>), ins, withDict)

asdf :: Dict (Set.Subset s t) -> Dict (Set.Subset t v) -> Dict (Set.Subset s v)
asdf = undefined

--instance Class (Set.Subset s t, Set.Subset t v) (Set.Subset s v) where 
--cls = Sub Dict

-- instance forall s t x. (Set.Subset s t) :=> (Set.Subset s (x ': t), Set.Subset (x ': s) (x ': t)) where ins = Sub Dict

aaa :: (Set.Subset s t) => Dict (Set.Subset s (x ': t))
aaa = Dict
bbb :: (Set.Subset s t) => Dict (Set.Subset (x ': s) (x ': t))
bbb = Dict

dd :: Dict (Set.Subset s t) -> Dict (Set.Subset s (x ': t) , Set.Subset (x ': s) (x ': t))
--dd a = withDict a (aaa, bbb)
dd a = undefined

known = undefined
data Subset where{}
transitive = undefined







class Sendable (recipients :: [Party]) (senders :: [Party]) c t where
  send :: forall r.
          (Member c r) =>
          Located senders t -> Sem r (Located (Union recipients senders) t)

instance (IsSet recipients,
          IsSet senders,
          IsSet parties,
          Subset recipients parties,
          Subset senders parties) =>
         Sendable recipients senders (Communicate parties s) s where
  send l = let lj = Just <$> l
               rp = immediateSubset @recipients
               sp = immediateSubset @senders
           in do l' <- sendMaybe (unionOfSubsets rp sp) sp lj
                 return (fromJust <$> l')
instance (IsSet recipients,
          IsSet senders,
          IsSet parties,
          Subset recipients parties,
          Subset senders parties) =>
         Sendable recipients senders (Communicate parties s) () where
  send _ = return (Located ())


class Sendable s t where
  -- Implementations must guarentee that `deserialize . serialize == id`.
  serialize :: t -> [s]
  deserialize :: [s] -> t

send :: forall (recipients :: [Party]) (senders :: [Party]) (parties :: [Party]) r s t.
        (IsSet recipients,
         IsSet senders,
         IsSet parties,
         Subset recipients parties,
         Subset senders parties,
         Member (Communicate parties s) r,
         Sendable s t) =>
        Located senders t -> Sem r (Located (Union recipients senders) t)
send l = do ls' <- sendList ls
            return (deserialize <$> ls')
  where rp = immediateSubset @recipients
        sp = immediateSubset @senders
        sendMb mb = sendMaybe (unionOfSubsets rp sp) sp (Located mb)
        ls = serialize <$> l
        sendList :: Located senders [s] -> Sem r (Located (Union recipients senders) [s])
        sendList (Located []) = do na <- sendMb Nothing
                                   return (maybeToList <$> na)
        sendList (Located (v:vs)) = do v' <- sendMb (Just v)
                                       vs' <- sendList (Located vs)
                                       return ((:) <$> (fromJust <$> v') <*> vs')

instance Sendable s s where
  serialize = (: [])
  deserialize = head
instance Sendable s () where
  serialize = const []
  deserialize = const ()
instance (Sendable s t) => Sendable s (Maybe t) where
  serialize = const []
  deserialize = const ()
